The game designer is building a single-player game in Pygame by modeling this game as a Markov Decision Process (MDP). Your task is to define and code new state transition functions according to the feature requested by the game designer.
The game has the following implementation already:
```python
import pygame
import sys
import random


class StateManager:
    def __init__(self):
        # height of the gameplay screen
        self.SCREEN_HEIGHT = int(600)
        
        # width of the gameplay screen
        self.SCREEN_WIDTH = int(800)
        
        # fps of the gameplay screen
        self.FPS = int(60)
        
        # The fixed x-coordinate of the bird character
        self.bird_x_position = int(100)
        
        # Height of the bird character
        self.bird_height = int(25)
        
        # Width of the bird character
        self.bird_width = int(25)
        
        # The color of the bird character in RGB format
        self.bird_color = tuple(tuple((255, 204, 0)))
        
        # The x-coordinate for the rightmost position to start drawing pipes
        self.pipe_spawn_x = int(800)
        
        # Vertical space between the upper and lower pipes
        self.pipe_gap = int(150)
        
        # The color of the pipes in RGB format, which should not be white
        self.pipe_color = tuple(tuple((0, 255, 0)))
        
        # Width of each pipe
        self.pipe_width = int(50)
        
        # Velocity at which the pipes move left across the screen
        self.pipe_velocity = int(5)
        
        # Height of the upper part of a pipe pair, with a default that ensures a gap
        self.pipe_upper_height = int(200)
        
        # The time interval in frames between spawning new pipe pairs
        self.pipe_spawn_interval = int(90)
        
        # Counter to track the frames elapsed since the last pipe spawn
        self.frame_counter = int(0)
        
        # List of positions of pipe pairs, where each pair is a dictionary with x, upper_y, and lower_y
        self.pipes_list = list([{'x': 800, 'upper_y': 0, 'lower_y': 350}])
        
        # Indicates whether the game is currently active or not. Used to check game over condition upon collision or out-of-bounds.
        self.game_active = bool(True)
        
        # The score of the player, representing the number of pipes successfully passed
        self.score = int(0)
        
        # The color of the score text in RGB format, ensuring visibility over the background
        self.score_text_color = tuple(tuple((0, 0, 0)))
        
        # The font size of the score text
        self.score_font_size = int(30)
        
        # The x-coordinate for where to display the score on the screen
        self.score_position_x = int(10)
        
        # The y-coordinate for where to display the score on the screen
        self.score_position_y = int(50)
        
        # The current y-coordinate of the bird character
        self.bird_y_position = int(300)
        
        # The velocity at which the bird moves up or down
        self.bird_velocity = int(5)
        
        # The color of the game over text in RGB format, ensuring visibility over the background.
        self.game_over_text_color = tuple(tuple((255, 0, 0)))
        


# the new function will be here



def main():
    state_manager = StateManager()
    running = True
    while running:
        event = pygame.event.poll()
        if event.type == pygame.QUIT:
            running = False
        # {function_description}
        {function_name}(state_manager)
    pygame.quit()

if __name__ == "__main__":
    pygame.init()
    main()
```

Please implement the following request from the game designer and return your answer in the following format:
```json
{
    "function_name": "spawn_and_move_pipes",
    "function_description": "This function should ensure that new pipes are continuously generated even as the game progresses indefinitely. It should adjust the generation pattern of pipes to maintain consistent difficulty, such as by randomizing the height of pipes within a range that is challenging yet fair. New pipe pairs need to spawn off-screen and enter the view as other pipes exit, keeping the number of pipes on-screen consistent and ensuring the bird always has new obstacles to navigate.",
    "function_implementation": "the pygame implementation of the function, including the first line of the function definition",
}
```

Here are the dos and don'ts for this request:
- Only implement things that pertain to updating the state variables. Other aspects of the game like input event handling and UI components will be handled separately.
- Minimize the number of functions added while meeting the game designer's requirements.
- Include only the essential details requested by the game designer. Do not add things that are not requested.
- These state transition functions will be called in every iteration of the main game loop. If you want to add a conditional logic to the function, please implement it in the function itself.
- Note that the new function will be added to the end of the list of state transition functions.

====================

{
    "function_name": "spawn_and_move_pipes",
    "function_description": "This function should ensure that new pipes are continuously generated even as the game progresses indefinitely. It should adjust the generation pattern of pipes to maintain consistent difficulty, such as by randomizing the height of pipes within a range that is challenging yet fair. New pipe pairs need to spawn off-screen and enter the view as other pipes exit, keeping the number of pipes on-screen consistent and ensuring the bird always has new obstacles to navigate.",
    "function_implementation": "def spawn_and_move_pipes(state_manager):\n    # Update frame counter\n    state_manager.frame_counter += 1\n    # Remove pipes that have moved off the screen\n    state_manager.pipes_list = [pipe for pipe in state_manager.pipes_list if pipe['x'] + state_manager.pipe_width > 0]\n    # Move existing pipes\n    for pipe in state_manager.pipes_list:\n        pipe['x'] -= state_manager.pipe_velocity\n    # Spawn new pipes if the interval is reached\n    if state_manager.game_active and state_manager.frame_counter >= state_manager.pipe_spawn_interval:\n        # Reset the frame counter\n        state_manager.frame_counter = 0\n        # Calculate a random height for the new upper pipe within a challenging yet fair range\n        upper_height = random.randint(50, state_manager.SCREEN_HEIGHT - state_manager.pipe_gap - 50)\n        # Add a new pipe pair to the end of the pipes list\n        new_pipe_pair = {'x': state_manager.SCREEN_WIDTH, 'upper_y': upper_height - state_manager.pipe_width, 'lower_y': upper_height + state_manager.pipe_gap}\n        state_manager.pipes_list.append(new_pipe_pair)\n"
}